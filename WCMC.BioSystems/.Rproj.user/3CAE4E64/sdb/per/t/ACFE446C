{
    "collab_server" : "",
    "contents" : "## MeSH RICH - Enrichment Analysis using MeSH terms annotated for metabolites. At the moment, we only annotate MeSH classification annotations.\n## For an input list, it would be first get the all the MeSH terms, and then calculate the chemical similarity networks and then put labels that are more than half of the compunds are having within a cluster. Fructose, ribose and fucose do not match by inchikeys, cid or even names. f this. feb2\nlibrary(pacman)\npacman::p_load(rcdk, RCy3, piano,RJSONIO,RCurl,stringr, ggplot2, httr,grid, png,ReporteRs,svglite, doSNOW, foreach,ggrepel,gridExtra,ape,plotrix)\n\nstat_res <- read.delim(\"C:/Users/barupal-pc/Google Drive/WCMC_Projects/ColumbiaUniversity/stat_results.txt\", header = T, stringsAsFactors = F)\ncpdnamevec <- tolower(stat_res$Name)\n## Technically, this should allows us to make a ID mapping r-package. That should be done, I think.\ncid_mesh <- read.delim(\"D:/NLM_Data_PubMed/MeshTagger/FinalExport/cid_name_ctree_dcat_expandeded.txt\", stringsAsFactors = F, header = F)\ncid_ik <- read.delim(\"D:/NLM_Data_PubMed/MeshTagger/mesh_pubchem_inchikeys.txt\", header = F, stringsAsFactors = F)\nlmdf <- read.delim(\"D:/NLM_Data_PubMed/MeshTagger/LMSDFDownload6Dec16/lipidmapdf.txt\", stringsAsFactors = F, header = T)\ncidmesh <- read.delim(\"D:/NLM_Data_PubMed/MeshTagger/CID-MeSH\", header = F, stringsAsFactors = F)\n\ncutoff <- 0.80\n# Step 1. Fix the cids that are not in the MeSH cid mapping and matched by name.\ncidnamevec <- tolower(cidmesh$V2)\nleftind <- which(stat_res$CID%in%cidmesh[,1]==FALSE)\nleftnames <- stat_res$Name[leftind]\ndf.names <- lapply(tolower(leftnames),function(x) {cbind(x,cidmesh$V1[which(cidnamevec==x)[1]])})\ndf.names <- do.call(rbind,df.names)\ndf.names <- df.names[!is.na(df.names[,2]),]\nstat_res$CID[ which(cpdnamevec%in%df.names[,1]==TRUE)] <- df.names[,2] ## this would fix the CIDs that have been mapped wrongly to the compounds in the input table.\n\ncid_mesh.small <- cid_mesh[which(cid_mesh[,1]%in%stat_res$CID==TRUE),]\n#cid_mesh.small <- cid_mesh.small[-which(duplicated(cid_mesh.small)==TRUE),]\n\n## Mesh & lipidMaps Mapping\ndf.cid <- sapply(stat_res$CID, function(x) { cbind(x,cid_mesh.small$V6[which(cid_mesh.small$V1==x)]) })\ndf.cid <- df.cid[which(lapply(df.cid,ncol)==2)]\ndf.cid <- do.call(rbind, df.cid)\n\ndf.lipid <- sapply(stat_res$CID, function(x) { cbind(x,unlist(lmdf[which(lmdf$CID==x),c(5:7)])) })\ndf.lipid <- df.lipid[which(lapply(df.lipid,ncol)==2)]\ndf.lipid <- do.call(rbind, df.lipid)\n\ndf2.ik <- sapply(stat_res$InChiKeys, function(x) { cbind(x,unlist(lmdf[which(lmdf$InchiKeys==x),c(3:5)])) })\ndf2.ik <- df2.ik[which(lapply(df2.ik,ncol)==2)]\n\ndf2.ik <- do.call(rbind, df2.ik)\ndf2.ik <- do.call(rbind,sapply(1:nrow(df2.ik), function(x) {cbind(stat_res$CID[which(stat_res$InChiKeys==df2.ik[x,1])],df2.ik[x,2])})) ## lipidmaps ids using inchikeys.\n\ndf.mega <- rbind(df.cid,df.lipid,df2.ik)\ndf.mega <- df.mega[-duplicated(df.mega),]\ndf.mega <- data.frame(CID=as.character(df.mega[,1]), Class=as.character(df.mega[,2]) )\n\n#length(unique(as.character(df.mega[,1]))) ## this is the count of metabolites that can be mapped to ontologies using CIDs.\n#main_mesh_ids <- read.delim(\"D:/NLM_Data_PubMed/MeshTagger/FinalExport/main_mesh_tree_annotations_v1.txt\", header = F, stringsAsFactors = F)\n### Chemical Similarity Networks\ndf1 <- stat_res\ndf1 <- df1[order(df1$P_value),]\n\npvals <- df1$P_value\nfcvec <- df1$FoldChange\n\ndf1$xsize <- \"x10\"\ndf1$xsize[which(df1$FoldChange<1 & df1$FoldChange>1/2)] <- 'x20'\ndf1$xsize[which(df1$FoldChange<1/2 & df1$FoldChange>1/3)] <- 'x50'\ndf1$xsize[which(df1$FoldChange<1/3 & df1$FoldChange>1/4)] <- 'x80'\ndf1$xsize[which(df1$FoldChange<1/4 & df1$FoldChange>1/10)] <- 'x150'\ndf1$xsize[which(df1$FoldChange<1/10 & df1$FoldChange>1/100)] <- 'x150'\ndf1$xsize[which(df1$FoldChange<0.01)] <- 'x200'\ndf1$xsize[which(df1$FoldChange>1 & df1$FoldChange<1.5)] <- 'x20'\ndf1$xsize[which(df1$FoldChange>1.5 & df1$FoldChange<2.0)] <- 'x40'\ndf1$xsize[which(df1$FoldChange>2 & df1$FoldChange<3)] <- 'x80'\ndf1$xsize[which(df1$FoldChange>3 & df1$FoldChange<4)] <- 'x100'\ndf1$xsize[which(df1$FoldChange>4 & df1$FoldChange<10)] <- 'x150'\ndf1$xsize[which(df1$FoldChange>10)] <- 'x200'\ndf1$xsize[which(df1$Pvalue<0.10)] <- \"x10\"  ### we apply a p-value cutoff and fix the sizes.\n\ncutoff <- as.numeric(cutoff)\nsmiles <- as.character(df1$SMILES)\ncids <- c(1:length(smiles))\ncids <- paste(\"node\",cids,sep=\"\")\n\ncl<-makeCluster(6) ## number of cores goes here, for calculating faster.\nregisterDoSNOW(cl)\nfps <- foreach (i = 1:length(smiles)) %dopar% {\n  library(rcdk)\n  return(get.fingerprint(parse.smiles(smiles[i])[[1]],type=\"pubchem\"))\n}\nstopCluster(cl)\n\ns <- fp.sim.matrix(fps, fplist2=NULL, method='tanimoto')\n\n### HCL based linking, to get the fully connected network.\nhc <- hclust(as.dist(1-s))\ns <- s[,hc$order] ## the original metamapp approach. wow, it was that easy to implement.\ns <- s[hc$order,]\ncids <- cids[hc$order]\ndf1 <- df1[hc$order,]\n\nnclus <- 25\npalette <- c('red','blue','green','orange','black','grey','yellow','pink','brown','purple','violet','skyblue','khaki','lavender','gold','magenta','yellowgreen','honeydew','blueviolet','chocolate','plum','thistle','salmon','olivedrab','slategray')[1:nclus]\nclus    <-cutree(hc,nclus)\nX <- as.phylo(hc)\nedge.clus <- sapply(1:nclus,function(i)max(which(X$edge[,2] %in% which(clus==i))))\norder     <- order(edge.clus)\nedge.clus <- c(min(edge.clus),diff(sort(edge.clus)))\nedge.clus <- rep(order,edge.clus)\nplot(X,type='fan', show.tip.label=FALSE,tip.color=palette[clus],edge.color=palette[edge.clus], edge.width=3)\narctext(x = \"smaller & stretched\", center = c(0, 0), radius = .52, middle = 2*pi , cex = 2, stretch = 0.5) # change the pi to change the location of the labels. We could extend it to show the p-value graphs.\n\n\n##\n\ndiag(s) <- 0\ns[lower.tri(s)]<-0\ndfmax <- cbind(cids,\"tmsim\",cids[sapply(1:length(cids), function (k) {which.max(s[k,]) })])\n\ndf2 <- data.frame(nodeid=cids,df1)\ndf2$nodeid <- as.character(df2$nodeid)\ndf2$weight <- 1\ndf2$CID <- as.character(df2$CID)\n#df2$CID..BinBase. <- as.character(df2$CID..BinBase.)\n##thvec <- (65+1:6*5)/100 # stepwise thresholding to get multi level pvalues.\ndf2$threshold <- rep(cutoff,nrow(df2))\nchemsimdf <- do.call(rbind,sapply(1:length(cids), function (k) { if(length(which(s[k,]>cutoff))>0) {cbind(cids[k],\"tmsim\",cids[which(s[k,]>cutoff)])}} ))\nchemsimdf <- rbind(chemsimdf, dfmax )\nedge.tbl <- data.frame(Gene.1=chemsimdf[,1], Gene.2=chemsimdf[,3])\n#edge.tbl <- edge.tbl[-which(edge.tbl$Gene.2==\"\"),]\nedge.tbl <- rbind(edge.tbl,data.frame(Gene.1= edge.tbl$Gene.2,Gene.2= edge.tbl$Gene.1))\nedge.tbl <-  edge.tbl[!duplicated( edge.tbl),]\nedge.tbl <- edge.tbl[order(edge.tbl$Gene.2,decreasing = F),]\nedge.tbl <- edge.tbl[order(edge.tbl$Gene.1,decreasing = F),]\nedge.tbl$Gene.1 <- as.character(edge.tbl$Gene.1)\nedge.tbl$Gene.2 <- as.character(edge.tbl$Gene.2)\n\npmids_a <- as.character(unique(edge.tbl$Gene.1))\nfor (i in 1:length(pmids_a)) {\n  sind <- c((max(which(edge.tbl$Gene.1==pmids_a[i])) +1) :nrow(edge.tbl))\n  edge.tbl$Gene.2[which(edge.tbl$Gene.2[sind]==pmids_a[i]) + (sind[1]-1) ] <- \"XX\"\n}\nedge.tbl <- edge.tbl[-which(edge.tbl$Gene.2==\"XX\"),]\nedge.tbl$edgeType <- \"tm\"\nedge.tbl$weight <- 1\n\n###\n\ncid_kegg <- read.delim(\"C:/Users/barupal-pc/Google Drive/WCMC_Projects/ColumbiaUniversity/cid_keggs.txt\", header = T, stringsAsFactors = F)\nkeggids <- cid_kegg[,2]\nkrp <- read.delim(\"./data/KRPlinks.txt\",header = F,stringsAsFactors = F)\nkrp.1 <- match(krp[,1],keggids)\nkrp.2 <- match(krp[,2],keggids)\nkrp.cbind <- cbind (krp.1,krp.2)\nkrp.net <- subset(krp.cbind, krp.1!=\"NA\" & krp.2!=\"NA\")\ncid.krp.2 <- cid_kegg[,1][krp.net[,2]]\ncid.krp.1 <- cid_kegg[,1][krp.net[,1]]\nkrp.cid.net <- data.frame(cid.krp.1,cid.krp.2)\nkrp.cid.net <- lapply(1:length(cid.krp.1), function(x) {cbind(cids[which(df2$CID==cid.krp.1[x])],cids[which(df2$CID==cid.krp.2[x])])}) ## there isa problem with the second column, but its okay. there is an error here, fix that. FEb, 8, 2017.\nkrp.cid.net<- krp.cid.net[which(lapply(krp.cid.net,length)==2)]\nkrp.cid.net <- do.call(rbind, krp.cid.net)\n\nkrp.cid.df <- data.frame(Gene.1 = krp.cid.net[,1],Gene.2=krp.cid.net[,2],edgeType=\"krp\",weight=1)\n\nedge.tbl.merged <- rbind(edge.tbl,krp.cid.df) ### input for the cyPlot command\n\ncg <- cyPlot(df2, edge.tbl.merged )\ncw <- CytoscapeWindow (paste0(\"pubchem_\",cutoff,\"\"), graph=cg,overwriteWindow = T)\ndisplayGraph (cw)\nlayoutNetwork(cw, 'circular')\n\ngetURL(paste0('http://localhost:1234/v1/commands/cluster/glay?network=',paste0(\"pubchem_\",cutoff),'&selectedOnly=false'))\n\ncontrol.points <- c(min(as.numeric(fcvec)), 0.99999,1.00001, max(as.numeric(fcvec))+1)   # typical range of log-fold-change ratio\nnode.colors <-  c(\"#0000AA\", \"#0000AA\",\"#FF0000\", \"#FF0000\")\nsetNodeColorRule (cw,\"FoldChange\", control.points, node.colors , mode = \"interpolate\")\nsetNodeSizeRule (cw,\"xsize\", unique(df2$xsize), as.numeric(gsub(\"x\",\"\", unique(df2$xsize) )), mode=\"lookup\"  )\n#setNodeLabelRule(cw,\"LipidName\")\n\nlayoutNetwork(cw, \"allegro-spring-electric\")\nfitContent(cw)\nsaveImage(cw, paste0(\"pubsim_\",cutoff),\"png\", 1600)\n\n##EnrichmentAnalysis\nnetworkid <- cw@window.id\n#networkid <- 26088\nviewid <- fromJSON(paste0('http://localhost:1234/v1/networks/',networkid,'/views/'))\nnetworkdata <- fromJSON(paste0('http://localhost:1234/v1/networks/',networkid,'/views/',viewid,'/network/'))\nxcenter <- as.numeric(networkdata[[2]]$value) ##+- of this value would define the ggplot x axis spread.\nycenter <- as.numeric(networkdata[[3]]$value)\nscalefactor <- as.numeric(networkdata[[9]]$value)\n\nnodetable <- fromJSON(paste0('http://localhost:1234/v1/networks/',networkid,'/tables/defaultnode'))\nnodetable <- as.data.frame(do.call(rbind, nodetable$rows))\nfor (i in 1:ncol(nodetable)) {\n  nodetable[,i] <- unlist(nodetable[,i])\n}\n\nnodedata <- nodetable\nnodedata$x <- sapply(nodedata$SUID, function(x) { fromJSON(paste0(\"http://localhost:1234/v1/networks/\",networkid,\"/views/\",viewid,\"/nodes/\",x,\"/NODE_X_LOCATION\"))$value })\nnodedata$y <- sapply(nodedata$SUID, function(x) { fromJSON(paste0(\"http://localhost:1234/v1/networks/\",networkid,\"/views/\",viewid,\"/nodes/\",x,\"/NODE_Y_LOCATION\"))$value })\nnodedata$color <- sapply(nodedata$SUID, function(x) { fromJSON(paste0(\"http://localhost:1234/v1/networks/\",networkid,\"/views/\",viewid,\"/nodes/\",x,\"/NODE_FILL_COLOR\"))[2] })\n\n########## Glay Enrichment Scoring\nglaydf1 <- cbind( nodedata$shared_name , nodedata$`__glayCluster`)\ngstatsdirection1 <- rep(1,nrow(glaydf1))\ngstatsdirection1[which(nodedata$FoldChange<1)]   <- -1 ## on a pvalue of this threshold, how many were affected or not.\nnames(gstatsdirection1) <- nodedata$shared_name\ngsdf <- loadGSC(glaydf1)\ngsares <- runGSA(geneLevelStats=gstatsdirection1,geneSetStat = 'fgsea', gsc=gsdf, nPerm=1000)\ngsa_res <- GSAsummaryTable(gsares)\ngsa_res$threshold <- cutoff\n\nexcdf <- gsa_res\n\ndf21 <- cbind(nodedata,do.call(rbind, lapply(nodedata$`__glayCluster`, function(x) { excdf[which(gsa_res$Name==x),]})))\n#names(df21) <- gsub(\"[(]|[)]\",\"\",gsub(\" \",\"_\",names(df21)))\nwrite.table( df21, file=paste(paste0(\"cpd_enrichment_results_\",cutoff,\".tsv\"), sep=\"\" ), col.names = T, row.names = F, quote = F, sep = \"\\t\" )\n\n\nfsize <- rep(5,nrow(gsa_res))\nfsize[which(gsa_res$`p (dist.dir.up)` <0.1|gsa_res$`p (dist.dir.dn)` <0.1)] <- 8\nfcolor <- rep(\"#0800fc\",nrow(gsa_res))\nfcolor[which(is.na(gsa_res$`p (dist.dir.dn)`)==TRUE)] <- \"#fc0000\"\n################\nexcludeCat <- c(\"Organic Chemicals\",\"Amino Acids, Peptides, and Proteins\",\"Amino Acids\",\"Heterocyclic Compounds\",\"Lipids\",\"character(0)\") ## these categories would be excluded as they are major classes would show in the labels oftern then others.\nannodb <-df.mega\nannodb$GlayCluster <- sapply(annodb[,1],function(x) { nodedata$`__glayCluster`[which(nodedata$CID==x)[1]]})\nannodb <- annodb[-which(annodb$Class%in%excludeCat==TRUE),]\nannodb <- annodb[-which(duplicated(annodb)==TRUE),]\n\nimg1 <- GET(paste0('http://localhost:1234/v1/networks/',networkid,'/views/first.png'),query=list(h=1600))\n#img1 <- GET(paste0('http://localhost:1234/v1/networks/2256/views/first.png'),query=list(h=1600))\nimg2 <- png::readPNG(img1$content)\nbg <- grid::rasterGrob(img2) ## this will be the backgroun of the ggplot\n\nxydf <- data.frame(x=as.numeric(nodedata$x), y=as.numeric(nodedata$y))\n\ndata_bw <- data.frame(x=as.numeric(xydf[,1]),y=as.numeric(xydf[,2]), cluster=nodedata$`__glayCluster`)\ndata_bw$cluster <- as.factor(data_bw$cluster)\ndata_bw$y <- abs(data_bw$y)-data_bw$y-abs(data_bw$y)\n\nclustnames <- sapply(unique(data_bw$cluster), function(x) { paste(names(sort(table(annodb$Class[which(annodb$GlayCluster==x)]), decreasing = T)[1:2]),collapse=\"\\n\")})\nclust_pvals.up <- excdf[,5]\nclust_pvals.dn <- excdf[,7]\nclust_pvals.up[is.na(clust_pvals.up)] <- clust_pvals.dn[is.na(clust_pvals.up)]\nexcdf$CpdName <- clustnames\n#clustnames <- paste(c(paste0(LETTERS,c(\"A\")),paste0(LETTERS,c(\"B\")))[1:nrow(data_bw.labels)],clust_pvals.up,clustnames,sep=\"__\")\n\npval <- rep(\"grey\",nrow(gsa_res))\npval[which(clust_pvals.up <0.1)] <- \"White\"\n\npval.alpha <- rep(1,length(pval))\npval.alpha[which(pval==\"grey\")] <-0.4\n\n\ncolnames(excdf) <- c(\"ClusterID\",\"Total Compounds\",\"Stat_dist_dir\",\"pvalue_up\",\"pvalue_up_adjusted\",\"pvalue_down\",\"pvalue_down_adjusted\",\"Compounds (UP)\",\"Compounds (Down)\",\"Chemical Similarity Threshold\",\"CompoundClass\")\nexcdf1 <- excdf\nexcdf1$CompoundClass <- gsub(\"\\n\",\"\",excdf$CompoundClass)\nwrite.table(excdf1, file=paste0(\"enrichment_results_\",cutoff,\".tsv\"), col.names = T, row.names = F, quote = F, sep = \"\\t\" )\n\ndata_bw.labels <- data.frame(x1= sapply(unique(data_bw$cluster), function(x) {  median(data_bw$x[which(data_bw$cluster==x)])  }), y1=sapply(unique(data_bw$cluster), function(x) {  median(data_bw$y[which(data_bw$cluster==x)]) }) , lnames= clustnames, pval = pval, clustPvalue=clust_pvals.up, labsize=fsize, labcol=fcolor)\ndata_bw.labels$labCode <-  c(paste0(LETTERS,c(\"A\")),paste0(LETTERS,c(\"B\")))[1:nrow(data_bw.labels)]\ndata_bw.labels$x2 <- rep(xcenter-xscale_adjust,nrow(data_bw.labels))\ndata_bw.labels$x2[which(data_bw.labels$x1>xcenter)] <-xcenter+xscale_adjust\n\n#data_bw.labels$x2[which(data_bw.labels$x2<xcenter)] <- data_bw.labels$x2[which(data_bw.labels$x2<xcenter)]+xscale_adjust*.05\ndata_bw.labels$x2[which(data_bw.labels$x2>xcenter)] <- data_bw.labels$x2[which(data_bw.labels$x2>xcenter)]-xscale_adjust*.35\n\n# data_bw.labels$x1[order(data_bw.labels$x1)[1:3]] <- sort(data_bw.labels$x1)[1:3] -  (xcenter*.12)\n# data_bw.labels$x1[order(data_bw.labels$x1, decreasing = T)[1:3]] <- sort(data_bw.labels$x1, decreasing = T)[1:3] +  (xcenter*.12)\n# data_bw.labels$y1[order(data_bw.labels$y1)[1:3]] <- sort(data_bw.labels$y1)[1:3] -  (ycenter*.25)\n# data_bw.labels$y1[order(data_bw.labels$y1, decreasing = T)[1:3]] <- sort(data_bw.labels$y1, decreasing = T)[1:3] +  (ycenter*.25)\n\n\nxscale_adjust <- networkdata[[12]]$value/scalefactor/ (networkdata[[12]]$value/networkdata[[7]]$value)\n#yscale_adjust <- (networkdata[[7]]$value/scalefactor)/2\n#ycenter <- -(ycenter)\nf2 <- ggplot() +\n  scale_x_continuous(limits = c( xcenter-xscale_adjust, xcenter+xscale_adjust))+\n  theme_bw() +\n  theme(\n    plot.title = element_text(face=\"bold\", size=14),\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    panel.grid.major = element_blank(), # switch off major gridlines\n    panel.grid.minor = element_blank(), # switch off minor gridlines\n    panel.background = element_rect(fill = \"transparent\",colour = NA), # or theme_blank()\n    plot.background = element_rect(fill = \"transparent\",colour = NA),\n    #legend.position = c(0.3,0.8), # manually position the legend (numbers being from 0,0 at bottom left of whole plot to 1,1 at top right)\n    legend.title = element_blank(), # switch off the legend title\n    legend.text = element_text(size=12),\n    legend.key.size = unit(1.5, \"lines\"),\n    legend.key = element_blank(), # switch off the rectangle around symbols in the legend\n    legend.spacing = unit(.05, \"cm\"),\n    legend.position=\"none\",\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank()\n  )\nf51 <- f2 + annotation_custom(bg, xmin= (xcenter-xscale_adjust), ymin=min(data_bw$y), xmax=(xcenter+xscale_adjust), ymax= max(data_bw$y) )\nf51 <- f51 +  stat_ellipse( data=data_bw, aes(x=x,y=y, group=cluster), size=2, alpha=0.1, geom='polygon', type = \"norm\", linetype = 1,show.legend=F, level=.90 )\n#f51 <- f51 + annotate(\"text\", x = data_bw.labels$x2, y = data_bw.labels$y1 , label = data_bw.labels$lnames , color=factor(data_bw.labels$labcol), size=fsize, alpha=pval.alpha,hjust = 0,check_overlap = TRUE)\nf51 <- f51 + annotate(\"label\", x = data_bw.labels$x1, y = data_bw.labels$y1 , label = data_bw.labels$labCode , fill = factor(data_bw.labels$labcol), color=pval, size=fsize, alpha=pval.alpha)\nplot(f51)\n#ggsave(paste0('chemclust_',cutoff,'.png'), plot=f51, width = 27,height=13.2)\n\n\nx1.min <- max(data_bw.labels$x1)+ (abs(min(data_bw.labels$x1))+max(data_bw.labels$x1))*0.20\nx1.max <- xcenter+xscale_adjust\ntab1 <- data_bw.labels[,c(8,5,3)]\nnames(tab1) <- c(\"LabelCode\",\"PValue\",\"ClusterName\")\ntab1 <- tab1[order(tab1$PValue),]\ntab1 <- tab1[which(tab1$PValue<.20),]\n#tab2 <- data_bw.labels[which(data_bw.labels$x2>xcenter),c(8,5,3)]\n#names(tab2) <- c(\"LabelCode\",\"PValue\",\"ClusterName\")\n#tab2 <- tab2[order(tab2$PValue),]\n#x2.min <- min(data_bw.labels$x1)- (abs(min(data_bw.labels$x1))+max(data_bw.labels$x1))*0.20\n#x2.max <- xcenter-xscale_adjust\nf61 <- f51 + annotation_custom(tableGrob(tab1,theme = ttheme_default(base_size = 15 ),rows = NULL), xmin=x1.min, xmax=x1.max, ymin=min(data_bw.labels$y1), ymax=-1)\n#f61 <- f61 + annotation_custom(tableGrob(tab1,theme = ttheme_default(base_size = 15 ),rows = NULL), xmin=x2.min, xmax=x2.max, ymin=min(data_bw.labels$y1), ymax=-1)\nplot(f61)\n\n\n\n# grrepel is a better solution, it just not workign at the moment.\n# f51 <- f2 + annotation_custom(bg, xmin= (xcenter-xscale_adjust), ymin=min(data_bw$y), xmax=(xcenter+xscale_adjust), ymax= max(data_bw$y) )\n# f51 <- f51 +  stat_ellipse( size=2, alpha=0.1, geom='polygon', type = \"norm\", linetype = 1,show.legend=F, level=.90 )\n# f51 + geom_text_repel(data=data_bw.labels,aes(x1, y1, label = as.character(data_bw.labels$lnames)))\n# plot(f51)\n\n\nwbp <- pptx(template = system.file(\"data\",\"chem_rich_temp.pptx\", package = \"ChemRICH\" ))\nwbp <- addSlide( wbp, \"lipidClust\" )\nwbp <- addPlot( wbp, function( ) grid::grid.raster(img2), offx =2.5 , offy = 1.1, width = 27, height = 13.2 , vector.graphic = TRUE )\nwbp <- addParagraph( wbp, value = paste(\"ChemRICH visualization : Node sizes shows the fold changes. Node color represents t-statistcs, red means increased and blue means decreased in the cases subjects on a p-value of 0.05. Network was created using a chemical similarity between metabolites as measured by the Tanimoto coefficient and the MetaMapp approach. Clusters , as shown by ellipses were detected by the glay community detection algorithm in Cytoscape. Labels shows the lipid classes where bold text means were found be to enriched in one study group on a pvalue threshold of 0.10. Blue labels shows that cluster was decreases in cases and red shows the opposite trend. See the supplementary files for pvalues of each enriched clusters as well as the individual compound. Threshold for the chemical similarity was 0.8.\", cutoff,sep=\" \") )\nwbp <- addSlide( wbp, \"lipidClust\" )\nwbp <- addPlot( wbp, function( ) print( f61 ), offx =2.5 , offy = 1.1, width = 27, height = 13.2 , vector.graphic = TRUE )\nwriteDoc( wbp, file = paste0(\"chemrich_\",cutoff,\".pptx\") )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1486966652267.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3481830703",
    "id" : "ACFE446C",
    "lastKnownWriteTime" : 1486620213,
    "last_content_update" : 1486620213,
    "path" : "C:/Users/barupal-pc/Google Drive/R_codes/Packages/Columbia.CFS.STudy/R/mainApp.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}