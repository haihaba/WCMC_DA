input = "batch	A	A	A	A	A	A	A	A	A	A	B	B	B	B	B	B	B	B	B	B
QC	TRUE	FALSE	FALSE	TRUE	FALSE	TRUE	FALSE	TRUE	FALSE	TRUE	TRUE	FALSE	FALSE	TRUE	FALSE	TRUE	FALSE	TRUE	FALSE	TRUE
injectionOrder	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
label	sample1	sample2	sample3	sample4	sample5	sample6	sample7	sample8	sample9	sample10	sample11	sample12	sample13	sample14	sample15	sample16	sample17	sample18	sample19	sample20
compound 1	0.717040388	0.659651829	0.253474418	0.498742095	0.104684888	0.741536693	0.171364524	0.199816171	0.518778929	0.100802113	0.029431465	0.711035709	0.096454553	0.661612928	0.061499574	0.300841344	0.53319109	0.279993187	0.219426149	0.963688534
compound 2	0.051841854	0.343722463	0.608954797	0.486795798	0.380934168	0.319949157	0.295947353	0.805249728	0.151151969	0.608991522	0.382352634	0.56267617	0.096437423	0.146905438	0.984374468	0.550833317	0.382373535	0.632782578	0.99862951	0.582337193
compound 3	0.724137221	0.52961621	0.978097601	0.061906738	0.59585323	0.848363904	0.026087233	0.632548023	0.096238912	0.826849429	0.256070658	0.938044088	0.911288389	0.307845868	0.783750681	0.672341182	0.653233888	0.054856194	0.1937571	0.319842697
compound 4	0.889163632	0.457507421	0.844317516	0.06583392	0.267612645	0.363107494	0.137405873	0.40579231	0.956126596	0.879955324	0.183688781	0.085171585	0.711215645	0.408384513	0.381409847	0.765618583	0.34042246	0.896419805	0.605380449	0.648986042
compound 5	0.972461465	0.984382508	0.463913386	0.728864941	0.679558196	0.152550853	0.496193466	0.233702584	0.177058884	0.850333968	0.932615358	0.331822101	0.124838053	0.684812414	0.480278763	0.191895033	0.940621195	0.674474921	0.264288256	0.314198666
compound 6	0.06060076	0.045121539	0.312667324	0.821086958	0.032533371	0.601770375	0.414714608	0.970155818	0.568697461	0.516438175	0.447164592	0.95307938	0.07504971	0.023139405	0.786721622	0.26789102	0.957184888	0.765466479	0.974630267	0.492096392
compound 7	0.216804445	0.025806781	0.158511734	0.861014698	0.740826772	0.331241237	0.201793658	0.772499847	0.657260858	0.807864818	0.296702346	0.382069095	0.210328004	0.424311514	0.998239178	0.715186916	0.557054293	0.094958638	0.037390492	0.194619275
compound 8	0.53034126	0.915260571	0.161199558	0.908258341	0.222915115	0.97021066	0.397746665	0.8293279	0.264638318	0.309888705	0.965287482	0.135792043	0.869481852	0.086003366	0.829018099	0.1859493	0.327589489	0.710790343	0.248407228	0.085684468
compound 9	0.983928716	0.595702429	0.478335027	0.305104287	0.219907348	0.844546403	0.570009827	0.986763804	0.957518816	0.66600426	0.147737937	0.99937345	0.777085863	0.493575356	0.679076212	0.099115371	0.985548012	0.741663016	0.677623709	0.661688914
compound 10	0.389764411	0.644769268	0.813645198	0.454585814	0.962824903	0.171654441	0.087748403	0.644060854	0.916846866	0.731022302	0.454599524	0.698998842	0.198929534	0.032747092	0.798540193	0.154394959	0.251410596	0.298283253	0.347618221	0.487116341
compound 11	0.832615156	0.441196028	0.623944401	0.638950474	0.355141598	0.155288914	0.174232732	0.952329384	0.423889112	0.099998619	0.202978293	0.489919036	0.477160644	0.523617028	0.229125406	0.421323206	0.194361532	0.815621744	0.76263245	0.802140046
compound 12	0.166262579	0.384694313	0.0367288	0.355384116	0.004324158	0.918298989	0.266979432	0.643695577	0.439164387	0.469836094	0.466928938	0.138120909	0.60536499	0.326447958	0.604342236	0.179953308	0.803356215	0.660189606	0.732536559	0.499388538
compound 13	0.852648848	0.217709002	0.813762609	0.185101166	0.155777733	0.494978264	0.702818763	0.330766045	0.996590271	0.260407668	0.810868006	0.164619325	0.274742462	0.383297897	0.936975265	0.315749138	0.208406213	0.486955564	0.249233776	0.768231743
compound 14	0.614003283	0.095718482	0.663188398	0.872137708	0.314032638	0.875404179	0.088932345	0.477486213	0.524946986	0.098560826	0.209967427	0.157965631	0.439165993	0.781715181	0.747362966	0.29507965	0.288032561	0.623706063	0.75871848	0.849549552
compound 15	0.322859417	0.949904486	0.482897354	0.470767322	0.612127	0.044823883	0.271465676	0.694145971	0.210130935	0.569060279	0.263049868	0.226309297	0.724921878	0.752478852	0.285249895	0.969763405	0.224671497	0.337951777	0.183621246	0.7094402
compound 16	0.752691054	0.18363602	0.582521402	0.181515376	0.862260302	0.81129301	0.186885935	0.379812499	0.8747522	0.979845377	0.420542971	0.963050229	0.678047836	0.414338207	0.730223002	0.42116849	0.872796859	0.050120363	0.588982214	0.282907765
compound 17	0.98190965	0.349967183	0.207781205	0.308272151	0.718386648	0.414848281	0.513463428	0.328323479	0.318023044	0.693854881	0.184336315	0.243255892	0.608892589	0.079692414	0.785452844	0.860272979	0.653649528	0.337516868	0.914982266	0.118659377
compound 18	0.185660146	0.458957507	0.037484984	0.343886808	0.956461155	0.152663833	0.570664426	0.742465184	0.116188058	0.089895491	0.939577415	0.47613037	0.857653105	0.32322958	0.377370637	0.350878533	0.416669454	0.991299071	0.195765713	0.63228539
compound 19	0.214036872	0.580049287	0.262380654	0.78337657	0.091046394	0.984668752	0.893128627	0.497364432	0.991940731	0.837219961	0.647014164	0.875848699	0.011533859	0.447765271	0.232079896	0.875444522	0.288747545	0.548393151	0.559528354	0.506370029
compound 20	0.163989835	0.402241435	0.91068825	0.385351514	0.140657493	0.586707196	0.090749668	0.725415105	0.373706664	0.83812031	0.630921464	0.62874516	0.378325118	0.002530656	0.409118167	0.919044187	0.248990301	0.640653658	0.664087056	0.980396551
"
library(pacman)
pacman::p_load(data.table)
input <- gsub("\r","",input)
cfile <- strsplit(input,"\n")[[1]]
df1 <- as.data.frame(do.call(rbind,lapply(cfile,function(x){strsplit(x,"\t")[[1]]})),stringsAsFactors = F)
p = df1[1:4,]
p = t(p)
colnames(p) = p[1,]
p = p[-1,]
p = data.frame(p,stringsAsFactors = F)
p$QC = as.logical(p$QC)
f=data.frame(df1[5:nrow(df1),1])
colnames(f) = 'compound label'
e = df1[5:nrow(df1),2:ncol(df1)]
e = as.matrix(e)
dim(e)
dim(f)
dim(p)
batch = matrix(p$batch,nrow = nrow(e),ncol = ncol(e),byrow = T)
View(batch)
get_loess_para = function(x,y,loess.span.limit = 0.5){ # use leave-one-out to select the best span parameter.
j = 0
error = rep(0, length(c(seq(loess.span.limit,1.5,0.1),1.75,2,2.25,2.5)))
for(par in c(seq(loess.span.limit,1.25,0.1),1.5,2)){
j = j+1
for(i in 2:(length(y)-1)){ # if i from 1 or to length(y), the prediction would be NA
o = loess(y[-i]~x[-i],span = par)
if(sum(is.na(o))){
error[j] = Inf
}else{
err = abs(predict(o,newdata = x[i]) - y[i])
error[j] = sum(error[j],err,na.rm = T)
}
}
}
return(c(seq(loess.span.limit,1.5,0.1),1.75,2,2.25,2.5)[which.min(error)])
}
remove_outlier = function(v){ # sometimes, the outlier of QC would be disaster when fitting loess. So we have to remove them.
out = boxplot(v,plot=F)$out
return(list(value = v[!v%in%out],index = which(v%in%out)))
}
QC.index = p$QC
batch = matrix(p$batch,nrow = nrow(e),ncol = ncol(e),byrow = T)
span.para
autoSpan=T
library(pacman)
pacman::p_load(data.table)
input <- gsub("\r","",input)
cfile <- strsplit(input,"\n")[[1]]
df1 <- as.data.frame(do.call(rbind,lapply(cfile,function(x){strsplit(x,"\t")[[1]]})),stringsAsFactors = F)
p = df1[1:4,]
p = t(p)
colnames(p) = p[1,]
p = p[-1,]
p = data.frame(p,stringsAsFactors = F)
p$QC = as.logical(p$QC)
f=data.frame(df1[5:nrow(df1),1])
colnames(f) = 'compound label'
e = df1[5:nrow(df1),2:ncol(df1)]
e = as.matrix(e)
get_loess_para = function(x,y,loess.span.limit = 0.5){ # use leave-one-out to select the best span parameter.
j = 0
error = rep(0, length(c(seq(loess.span.limit,1.5,0.1),1.75,2,2.25,2.5)))
for(par in c(seq(loess.span.limit,1.25,0.1),1.5,2)){
j = j+1
for(i in 2:(length(y)-1)){ # if i from 1 or to length(y), the prediction would be NA
o = loess(y[-i]~x[-i],span = par)
if(sum(is.na(o))){
error[j] = Inf
}else{
err = abs(predict(o,newdata = x[i]) - y[i])
error[j] = sum(error[j],err,na.rm = T)
}
}
}
return(c(seq(loess.span.limit,1.5,0.1),1.75,2,2.25,2.5)[which.min(error)])
}
remove_outlier = function(v){ # sometimes, the outlier of QC would be disaster when fitting loess. So we have to remove them.
out = boxplot(v,plot=F)$out
return(list(value = v[!v%in%out],index = which(v%in%out)))
}
QC.index = p$QC
batch = matrix(p$batch,nrow = nrow(e),ncol = ncol(e),byrow = T)
if(autoSpan){
span.para = "auto"
}else{
span.para = 0.75
}
loess.span.limit = 0.5
norms = parSapply(cl, X = 1:nrow(e), function(i,e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,
loess.span.limit){
models = by(data.frame(v=e[i,QC.index],t=p[[time]][QC.index]),
batch[i,QC.index],function(x){
# x = data.frame(v=e[i,QC.index],t=p[[time]][QC.index])[batch[i,QC.index]=="B",]
if(length(remove_outlier(x$v)[[2]])>0){# if outlier exists.
span = ifelse(span.para=='auto',
get_loess_para(x=x$t[-remove_outlier(x$v)[[2]]],y=remove_outlier(x$v)[[1]],
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}else{
span = ifelse(span.para=='auto',
get_loess_para(x=x$t,y=x$v,
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}
if(length(remove_outlier(x$v)[[2]])>0){
loess(v~t,data=x[-remove_outlier(x$v)[[2]],],span=span)
}else{
loess(v~t,data=x,span=span)
}
})
# predict using the models.
norm = mapply(function(u,v){
o = tryCatch({
predict(u,newdata = v)
},
error = function(e){
print(e)
v
})
},models,by(p[[time]],batch[i,],function(x){x}))
norm = unlist(norm)
# replace NA with the closest value.
if(length(which(is.na(norm)))>0){
for(j in which(is.na(norm))){
time_notNA = p[[time]][-which(is.na(norm))]
closest_time = time_notNA[which.min(abs(time_notNA - p[[time]][j]))]
norm[j] = norm[which(p[[time]]==closest_time)]
}
}
return(norm)
},e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,loess.span.limit)
pacman::p_load(data.table,parallel)
norms = parSapply(cl, X = 1:nrow(e), function(i,e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,
loess.span.limit){
models = by(data.frame(v=e[i,QC.index],t=p[[time]][QC.index]),
batch[i,QC.index],function(x){
# x = data.frame(v=e[i,QC.index],t=p[[time]][QC.index])[batch[i,QC.index]=="B",]
if(length(remove_outlier(x$v)[[2]])>0){# if outlier exists.
span = ifelse(span.para=='auto',
get_loess_para(x=x$t[-remove_outlier(x$v)[[2]]],y=remove_outlier(x$v)[[1]],
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}else{
span = ifelse(span.para=='auto',
get_loess_para(x=x$t,y=x$v,
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}
if(length(remove_outlier(x$v)[[2]])>0){
loess(v~t,data=x[-remove_outlier(x$v)[[2]],],span=span)
}else{
loess(v~t,data=x,span=span)
}
})
# predict using the models.
norm = mapply(function(u,v){
o = tryCatch({
predict(u,newdata = v)
},
error = function(e){
print(e)
v
})
},models,by(p[[time]],batch[i,],function(x){x}))
norm = unlist(norm)
# replace NA with the closest value.
if(length(which(is.na(norm)))>0){
for(j in which(is.na(norm))){
time_notNA = p[[time]][-which(is.na(norm))]
closest_time = time_notNA[which.min(abs(time_notNA - p[[time]][j]))]
norm[j] = norm[which(p[[time]]==closest_time)]
}
}
return(norm)
},e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,loess.span.limit)
.Platform$OS.type
cl = makeCluster(min(20,detectCores()))
cl
norms = parSapply(cl, X = 1:nrow(e), function(i,e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,
loess.span.limit){
models = by(data.frame(v=e[i,QC.index],t=p[[time]][QC.index]),
batch[i,QC.index],function(x){
# x = data.frame(v=e[i,QC.index],t=p[[time]][QC.index])[batch[i,QC.index]=="B",]
if(length(remove_outlier(x$v)[[2]])>0){# if outlier exists.
span = ifelse(span.para=='auto',
get_loess_para(x=x$t[-remove_outlier(x$v)[[2]]],y=remove_outlier(x$v)[[1]],
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}else{
span = ifelse(span.para=='auto',
get_loess_para(x=x$t,y=x$v,
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}
if(length(remove_outlier(x$v)[[2]])>0){
loess(v~t,data=x[-remove_outlier(x$v)[[2]],],span=span)
}else{
loess(v~t,data=x,span=span)
}
})
# predict using the models.
norm = mapply(function(u,v){
o = tryCatch({
predict(u,newdata = v)
},
error = function(e){
print(e)
v
})
},models,by(p[[time]],batch[i,],function(x){x}))
norm = unlist(norm)
# replace NA with the closest value.
if(length(which(is.na(norm)))>0){
for(j in which(is.na(norm))){
time_notNA = p[[time]][-which(is.na(norm))]
closest_time = time_notNA[which.min(abs(time_notNA - p[[time]][j]))]
norm[j] = norm[which(p[[time]]==closest_time)]
}
}
return(norm)
},e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,loess.span.limit)
time = p$injectionOrder
norms = parSapply(cl, X = 1:nrow(e), function(i,e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,
loess.span.limit){
models = by(data.frame(v=e[i,QC.index],t=p[[time]][QC.index]),
batch[i,QC.index],function(x){
# x = data.frame(v=e[i,QC.index],t=p[[time]][QC.index])[batch[i,QC.index]=="B",]
if(length(remove_outlier(x$v)[[2]])>0){# if outlier exists.
span = ifelse(span.para=='auto',
get_loess_para(x=x$t[-remove_outlier(x$v)[[2]]],y=remove_outlier(x$v)[[1]],
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}else{
span = ifelse(span.para=='auto',
get_loess_para(x=x$t,y=x$v,
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}
if(length(remove_outlier(x$v)[[2]])>0){
loess(v~t,data=x[-remove_outlier(x$v)[[2]],],span=span)
}else{
loess(v~t,data=x,span=span)
}
})
# predict using the models.
norm = mapply(function(u,v){
o = tryCatch({
predict(u,newdata = v)
},
error = function(e){
print(e)
v
})
},models,by(p[[time]],batch[i,],function(x){x}))
norm = unlist(norm)
# replace NA with the closest value.
if(length(which(is.na(norm)))>0){
for(j in which(is.na(norm))){
time_notNA = p[[time]][-which(is.na(norm))]
closest_time = time_notNA[which.min(abs(time_notNA - p[[time]][j]))]
norm[j] = norm[which(p[[time]]==closest_time)]
}
}
return(norm)
},e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,loess.span.limit)
remove_outlier
span.para
get_loess_para
loess.span.limit
i=1
e[i,QC.index]
apply(e,2,as.numeric)[1:2,1]
e[1:2,1]
e = apply(e,2,as.numeric)
norms = parSapply(cl, X = 1:nrow(e), function(i,e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,
loess.span.limit){
models = by(data.frame(v=e[i,QC.index],t=p[[time]][QC.index]),
batch[i,QC.index],function(x){
# x = data.frame(v=e[i,QC.index],t=p[[time]][QC.index])[batch[i,QC.index]=="B",]
if(length(remove_outlier(x$v)[[2]])>0){# if outlier exists.
span = ifelse(span.para=='auto',
get_loess_para(x=x$t[-remove_outlier(x$v)[[2]]],y=remove_outlier(x$v)[[1]],
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}else{
span = ifelse(span.para=='auto',
get_loess_para(x=x$t,y=x$v,
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}
if(length(remove_outlier(x$v)[[2]])>0){
loess(v~t,data=x[-remove_outlier(x$v)[[2]],],span=span)
}else{
loess(v~t,data=x,span=span)
}
})
# predict using the models.
norm = mapply(function(u,v){
o = tryCatch({
predict(u,newdata = v)
},
error = function(e){
print(e)
v
})
},models,by(p[[time]],batch[i,],function(x){x}))
norm = unlist(norm)
# replace NA with the closest value.
if(length(which(is.na(norm)))>0){
for(j in which(is.na(norm))){
time_notNA = p[[time]][-which(is.na(norm))]
closest_time = time_notNA[which.min(abs(time_notNA - p[[time]][j]))]
norm[j] = norm[which(p[[time]]==closest_time)]
}
}
return(norm)
},e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,loess.span.limit)
i
e[i,QC.index]
p[[time]]
time = "injectionOrder"
p[[time]][QC.index]
p$injectionOrder = as.numeric(p$injectionOrder)
data.frame(v=e[i,QC.index],t=p[[time]][QC.index])
p[[time]][QC.index])
p[[time]][QC.index]
x = data.frame(v=e[i,QC.index],t=p[[time]][QC.index])[batch[i,QC.index]=="B",]
length(remove_outlier(x$v)[[2]])>0
span = ifelse(span.para=='auto',
get_loess_para(x=x$t,y=x$v,
loess.span.limit = loess.span.limit),span.para) # find a proper span.
span
span.para
if(length(remove_outlier(x$v)[[2]])>0){
loess(v~t,data=x[-remove_outlier(x$v)[[2]],],span=span)
}else{
loess(v~t,data=x,span=span)
}
norms = parSapply(cl, X = 1:nrow(e), function(i,e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,
loess.span.limit){
models = by(data.frame(v=e[i,QC.index],t=p[[time]][QC.index]),
batch[i,QC.index],function(x){
# x = data.frame(v=e[i,QC.index],t=p[[time]][QC.index])[batch[i,QC.index]=="B",]
if(length(remove_outlier(x$v)[[2]])>0){# if outlier exists.
span = ifelse(span.para=='auto',
get_loess_para(x=x$t[-remove_outlier(x$v)[[2]]],y=remove_outlier(x$v)[[1]],
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}else{
span = ifelse(span.para=='auto',
get_loess_para(x=x$t,y=x$v,
loess.span.limit = loess.span.limit),span.para) # find a proper span.
}
if(length(remove_outlier(x$v)[[2]])>0){
loess(v~t,data=x[-remove_outlier(x$v)[[2]],],span=span)
}else{
loess(v~t,data=x,span=span)
}
})
# predict using the models.
norm = mapply(function(u,v){
o = tryCatch({
predict(u,newdata = v)
},
error = function(e){
print(e)
v
})
},models,by(p[[time]],batch[i,],function(x){x}))
norm = unlist(norm)
# replace NA with the closest value.
if(length(which(is.na(norm)))>0){
for(j in which(is.na(norm))){
time_notNA = p[[time]][-which(is.na(norm))]
closest_time = time_notNA[which.min(abs(time_notNA - p[[time]][j]))]
norm[j] = norm[which(p[[time]]==closest_time)]
}
}
return(norm)
},e,f,p,QC.index,batch,time,remove_outlier,span.para,get_loess_para,loess.span.limit)
norms = t(norms)
e_norm = matrix(NA,nrow=nrow(f),ncol=nrow(p))
divide = F
for(i in 1:nrow(f)){
e_norm[i,] = e[i,] - (norms[i,] - median(e[i,]))
}
rownames(e_norm) = rownames(e)
colnames(e_norm) = colnames(e)
stopCluster(cl)
e_norm = cbind(data.table(compounds=f$`compound label`),e_norm)
rownames(e_norm) = p$label
e_norm = cbind(data.table(compounds=f$`compound label`),e_norm)
e_norm
library(WCMC.Normalization.LOESS)
library(WCMC.Normalization.LOESS)
library(opencpu);
opencpu$browse("library/WCMC.Normalization.LOESS/www")
library(WCMC.Normalization.LOESS)
library(opencpu);
opencpu$browse("library/WCMC.Normalization.LOESS/www")
library(WCMC.Normalization.LOESS)
library(opencpu);
opencpu$browse("library/WCMC.Normalization.LOESS/www")
library(WCMC.Normalization.LOESS)
library(opencpu);
opencpu$browse("library/WCMC.Normalization.LOESS/www")
e_norm = WCMC.Fansly::toSameScale(e,e_norm)
e_norm
e
e_norm
library(WCMC.Normalization.LOESS)
library(opencpu);
opencpu$browse("library/WCMC.Normalization.LOESS/www")
library(WCMC.Normalization.LOESS)
library(opencpu);
opencpu$browse("library/WCMC.Normalization.LOESS/www")
library(WCMC.Normalization.LOESS)
library(WCMC.Normalization.LOESS)
library(opencpu);
opencpu$browse("library/WCMC.Normalization.LOESS/www")
